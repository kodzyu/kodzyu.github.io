<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Solar System — 3D</title>
<style>
  :root{ --bg:#05070e; --panel:#0e1424; --muted:#96a7c4; --text:#e6eeff; --accent:#62cbff; }
  html,body{height:100%;margin:0}
  body{background:radial-gradient(1200px 800px at 30% 20%, #0c1224, var(--bg)); color:var(--text); font:14px/1.4 system-ui; overflow:hidden}
  #app{position:fixed; inset:0}
  canvas{display:block}
  .panel{position:absolute; top:12px; right:12px; background:rgba(14,20,36,.88); border:1px solid #1d2844; border-radius:12px; padding:12px 14px; min-width:370px; box-shadow:0 10px 30px rgba(0,0,0,.45); backdrop-filter: blur(6px); transition:transform .25s ease, opacity .25s ease; padding-top:36px}
  .panel.minimized{transform:translateY(-92%); opacity:0; pointer-events:none}
  .panel h1{margin:0 0 8px; font-size:16px}
  .row{display:grid; grid-template-columns:160px 1fr auto; gap:8px; align-items:center; margin:8px 0}
  .row label{color:var(--muted)}
  .row input[type=range], .row select{width:100%}
  .row .value{min-width:90px; text-align:right; color:var(--accent); font-variant-numeric:tabular-nums}
  .toggles{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px}
  .toggle{display:flex; gap:8px; align-items:center; background:#0b1222; border:1px solid #223155; border-radius:10px; padding:6px 8px}
  button{background:#101a32; color:var(--text); border:1px solid #25365e; border-radius:10px; padding:8px 10px; cursor:pointer}
  button:hover{border-color:#3b5ea3}
  .legend{margin-top:8px; color:var(--muted); font-size:12px}
  .kbd{display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid #304060; background:#111827; color:#d1e2ff; font-size:11px}
  .footer{position:absolute; left:12px; bottom:10px; color:var(--muted); font-size:12px}
  /* Minimizer UI */
  .close-btn{position:absolute; top:8px; right:8px; width:28px; height:28px; border-radius:8px; border:1px solid #2a3c66; background:#0b1222; color:#dbe8ff; cursor:pointer; display:grid; place-items:center; line-height:1}
  .close-btn:hover{border-color:#3b5ea3}
  .mini-panel{position:fixed; top:12px; right:12px; width:42px; height:42px; display:none; place-items:center; border-radius:10px; border:1px solid #1d2844; background:rgba(14,20,36,.88); color:#e6eeff; box-shadow:0 10px 30px rgba(0,0,0,.45); cursor:pointer}
  .mini-panel .burger{font-size:20px; line-height:1}
  .mini-panel:hover{border-color:#3b5ea3}
</style>
</head>
<body>
<div id="app"></div>

<section class="panel" aria-label="Controls" id="controlPanel">
  <button id="panelClose" class="close-btn" title="Minimize controls" aria-label="Minimize">✕</button>
  <h1>Solar System — 3D (Sun in Motion)</h1>

  <div class="row">
    <label for="speed">Time speed</label>
    <input id="speed" type="range" min="0.01" max="600" step="0.01" value="80" />
    <div class="value"><span id="speedVal">80</span>× days/s</div>
  </div>
  <div class="row">
    <label for="scale">Scale (u per AU)</label>
    <input id="scale" type="range" min="5" max="80" step="1" value="24" />
    <div class="value"><span id="scaleVal">24</span> u/AU</div>
  </div>
  <div class="row">
    <label for="sunV">Sun forward speed</label>
    <input id="sunV" type="range" min="0" max="2" step="0.001" value="0.25" />
    <div class="value"><span id="sunVVal">0.25</span> AU/yr</div>
  </div>
  <div class="row">
    <label for="flySpeed">Flight speed</label>
    <input id="flySpeed" type="range" min="2" max="200" step="1" value="30" />
    <div class="value"><span id="flySpeedVal">30</span> u/s (×4 with Shift)</div>
  </div>

  <div class="toggles">
    <label class="toggle"><input type="checkbox" id="trails" checked/> Trails</label>
    <label class="toggle"><input type="checkbox" id="orbits" checked/> Orbit rings</label>
    <label class="toggle"><input type="checkbox" id="names" checked/> Names</label>
    <label class="toggle"><input type="checkbox" id="stars" /> Starfield</label>
    <label class="toggle"><input type="checkbox" id="milky" checked/> Milky Way skybox</label>
    <label class="toggle"><input type="checkbox" id="elliptical" checked/> Elliptical orbits</label>
    <label class="toggle"><input type="checkbox" id="moons" checked/> Moons</label>
    <label class="toggle"><input type="checkbox" id="axial" checked/> Axial tilt + spin</label>
  </div>

  <div class="row">
    <label for="focusPlanet">Focus planet</label>
    <select id="focusPlanet">
      <option>Sun</option>
      <option>Mercury</option>
      <option>Venus</option>
      <option>Earth</option>
      <option>Mars</option>
      <option>Jupiter</option>
      <option>Saturn</option>
      <option>Uranus</option>
      <option>Neptune</option>
    </select>
    <button id="focusGo">Go</button>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="followSun">Follow Target</button>
    <button id="resetCam">Reset Camera</button>
    <button id="play">⏸︎ Pause</button>
  </div>
  <div class="legend">Mouse: drag orbit • wheel zoom • Keys: <span class="kbd">WASD</span> move, <span class="kbd">Q/E</span> down/up, <span class="kbd">Shift</span> boost • <span class="kbd">R</span> reset • <span class="kbd">Space</span> play/pause</div>
</section>

<button id="miniPanel" class="mini-panel" title="Show controls" aria-label="Show controls"><span class="burger">☰</span></button>

<div class="footer">Includes: Saturn rings, focus planet dropdown, Milky Way skybox, non-wrapping trails, moons, WASD flight. Helical motion from Sun's forward speed.</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script>
if (!window.THREE) { alert('Three.js failed to load'); }
else {
  const T = window.THREE;
  const container = document.getElementById('app');
  const renderer = new T.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  const scene = new T.Scene();
  scene.fog = new T.FogExp2(0x03060f, 0.002);

  const camera = new T.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 20000);
  camera.position.set(140,100,260);

  const controls = new T.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new T.HemisphereLight(0x88aaff, 0x080a12, 0.22); scene.add(hemi);

  const el=id=>document.getElementById(id);
  const speedInput=el('speed'), speedVal=el('speedVal');
  const scaleInput=el('scale'), scaleVal=el('scaleVal');
  const sunVInput=el('sunV'), sunVVal=el('sunVVal');
  const flySpeedInput=el('flySpeed'), flySpeedVal=el('flySpeedVal');
  const trailsChk=el('trails'), orbitsChk=el('orbits'), namesChk=el('names');
  const starsChk=el('stars'), milkyChk=el('milky');
  const ellipticalChk=el('elliptical'), moonsChk=el('moons'), axialChk=el('axial');
  const focusSel=el('focusPlanet');
  const followSunBtn=el('followSun'), resetCamBtn=el('resetCam'), playBtn=el('play');
  const panel=el('controlPanel'), panelClose=el('panelClose'), miniPanel=el('miniPanel');

  let running=true, unitsPerAU=Number(scaleInput.value), daysPerSecond=Number(speedInput.value), sunAUPerYear=Number(sunVInput.value), t=0, followSun=true;
  let followTarget = null;

  // Minimize / restore panel
  panelClose.addEventListener('click', ()=>{ panel.classList.add('minimized'); miniPanel.style.display='grid'; });
  miniPanel.addEventListener('click', ()=>{ panel.classList.remove('minimized'); miniPanel.style.display='none'; });

  // WASD flight
  const keys = { w:false, a:false, s:false, d:false, q:false, e:false, shift:false };
  let baseSpeed = Number(flySpeedInput.value);
  flySpeedInput.addEventListener('input', ()=>{ baseSpeed = Number(flySpeedInput.value); flySpeedVal.textContent = String(baseSpeed); });
  window.addEventListener('keydown', (e)=>{
    if (['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) return;
    const k = e.key.toLowerCase();
    if (k==='w') keys.w=true; else if (k==='a') keys.a=true; else if (k==='s') keys.s=true; else if (k==='d') keys.d=true; else if (k==='q') keys.q=true; else if (k==='e') keys.e=true; else if (k==='shift') keys.shift=true;
    if (k===' ') { e.preventDefault(); playBtn.click(); }
    if (k==='r') { resetCamBtn.click(); }
  });
  window.addEventListener('keyup', (e)=>{ const k=e.key.toLowerCase(); if (k==='w') keys.w=false; else if (k==='a') keys.a=false; else if (k==='s') keys.s=false; else if (k==='d') keys.d=false; else if (k==='q') keys.q=false; else if (k==='e') keys.e=false; else if (k==='shift') keys.shift=false; });
  function applyWASD(dt){
    const any = keys.w||keys.a||keys.s||keys.d||keys.q||keys.e; if (!any) return;
    const speed = baseSpeed * (keys.shift ? 4 : 1) * dt;
    const forward = new T.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const right = new T.Vector3().crossVectors(forward, new T.Vector3(0,1,0)).normalize();
    const up = new T.Vector3(0,1,0);
    const delta = new T.Vector3();
    if (keys.w) delta.add(forward.clone().multiplyScalar(speed));
    if (keys.s) delta.add(forward.clone().multiplyScalar(-speed));
    if (keys.d) delta.add(right.clone().multiplyScalar(speed));
    if (keys.a) delta.add(right.clone().multiplyScalar(-speed));
    if (keys.e) delta.add(up.clone().multiplyScalar(speed));
    if (keys.q) delta.add(up.clone().multiplyScalar(-speed));
    camera.position.add(delta); controls.target.add(delta);
    if (followSun){ followSun=false; followSunBtn.textContent='Follow Target'; }
  }

  // Starfield (toggleable)
  const starGeo = new T.BufferGeometry();
  const starCount = 2500; const starPos = new Float32Array(starCount*3);
  for (let i=0;i<starCount;i++){ const r=3000*Math.pow(Math.random(),0.5)+300, th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1); starPos[i*3]=r*Math.sin(ph)*Math.cos(th); starPos[i*3+1]=r*Math.sin(ph)*Math.sin(th); starPos[i*3+2]=r*Math.cos(ph); }
  starGeo.setAttribute('position', new T.BufferAttribute(starPos,3));
  const stars = new T.Points(starGeo, new T.PointsMaterial({ size:2, color:0x9db8ff, sizeAttenuation:true, transparent:true, opacity:0.9 }));
  stars.visible = !!starsChk.checked; scene.add(stars);
  starsChk.addEventListener('change', ()=>{ stars.visible = !!starsChk.checked; });

  // Milky Way skybox — procedural texture on an inside-out sphere
  function makeMilkyWayTexture(w=2048,h=1024){
    const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
    g.fillStyle='#03060f'; g.fillRect(0,0,w,h);
    g.globalAlpha=1.0; g.fillStyle='#cfe2ff';
    const starN = 12000; for(let i=0;i<starN;i++){ const x=Math.random()*w, y=Math.random()*h; const s = Math.random()<0.7 ? 1 : 2; g.fillRect(x,y,s,s); }
    const bandWidth = h*0.28;
    for(let y=0;y<h;y++){
      const dy = y - h/2; const d = Math.abs(dy)/(bandWidth/2);
      let intensity = Math.exp(-d*d*1.5); if (intensity < 0.02) continue;
      const n = (Math.sin(y*0.012)+Math.sin(y*0.047)*0.5+Math.sin(y*0.081)*0.25)/1.75;
      intensity *= 0.75 + 0.35*n; const alpha = Math.min(0.9, intensity*0.6);
      const grad = g.createLinearGradient(0,y, w, y);
      grad.addColorStop(0, `rgba(180,200,255,${alpha*0.4})`);
      grad.addColorStop(0.5, `rgba(255,242,210,${alpha})`);
      grad.addColorStop(1, `rgba(180,200,255,${alpha*0.4})`);
      g.fillStyle = grad; g.fillRect(0,y,w,1);
    }
    g.globalAlpha=0.25; g.fillStyle='#02040a';
    for(let i=0;i<180;i++){ const yy = h*0.5 + (Math.random()-0.5)*bandWidth*0.9; const thickness = 1 + Math.random()*3; g.fillRect(0,yy,w,thickness); }
    const tex = new T.CanvasTexture(c); tex.wrapS=T.ClampToEdgeWrapping; tex.wrapT=T.ClampToEdgeWrapping; tex.needsUpdate=true; return tex;
  }
  const milkyTex = makeMilkyWayTexture();
  const milkySphere = new T.Mesh(new T.SphereGeometry(5000, 64, 32), new T.MeshBasicMaterial({ map: milkyTex, side: T.BackSide, fog: false, depthWrite:false }));
  milkySphere.visible = !!milkyChk.checked; scene.add(milkySphere);
  milkyChk.addEventListener('change', ()=>{ milkySphere.visible = !!milkyChk.checked; });

  // Sun + light
  const sun = new T.Mesh(new T.SphereGeometry(7,36,18), new T.MeshBasicMaterial({color:0xffd166})); scene.add(sun);
  const sunlight = new T.PointLight(0xffffff, 2.2, 0, 2); sunlight.position.copy(sun.position); scene.add(sunlight);

  // Planet data
  const planets = [
    { name:'Mercury', a:0.387, e:0.2056, period:87.97, color:0xc0b7a8, size:0.6, tilt:0.01, spin:1407.6 },
    { name:'Venus',   a:0.723, e:0.0068, period:224.70, color:0xf5d28c, size:0.95, tilt:177.4, spin:-5832.5 },
    { name:'Earth',   a:1.000, e:0.0167, period:365.256, color:0x7db6ff, size:1.05, tilt:23.44, spin:23.93 },
    { name:'Mars',    a:1.524, e:0.0934, period:686.98, color:0xff8a5c, size:0.9, tilt:25.19, spin:24.62 },
    { name:'Jupiter', a:5.203, e:0.0489, period:4332.59, color:0xf0d2a6, size:2.8, tilt:3.13, spin:9.93 },
    { name:'Saturn',  a:9.537, e:0.0565, period:10759,   color:0xf7e6b1, size:2.4, tilt:26.73, spin:10.7 },
    { name:'Uranus',  a:19.191,e:0.0472, period:30688.5, color:0xa7e7ff, size:2.2, tilt:97.77, spin:-17.24 },
    { name:'Neptune', a:30.07, e:0.0086, period:60182,   color:0x6aa7ff, size:2.1, tilt:28.32, spin:16.11 }
  ];

  function makeLabelSprite(text){ const c=document.createElement('canvas'); c.width=256; c.height=128; const g=c.getContext('2d'); g.fillStyle='rgba(20,30,50,0.7)'; g.fillRect(0,86,256,42); g.fillStyle='#d9e7ff'; g.font='28px system-ui'; g.fillText(text,10,114); const tex=new T.CanvasTexture(c); return new T.Sprite(new T.SpriteMaterial({map:tex,transparent:true})); }

  function createTrail(materialColor){
    const N = 1800; const positions = new Float32Array(N*3);
    const geo1 = new T.BufferGeometry(), geo2 = new T.BufferGeometry();
    const attr1 = new T.BufferAttribute(positions,3), attr2 = new T.BufferAttribute(positions,3);
    geo1.setAttribute('position', attr1); geo2.setAttribute('position', attr2);
    geo1.setDrawRange(0,0); geo2.setDrawRange(0,0);
    const mat = new T.LineBasicMaterial({ color: materialColor, transparent:true, opacity:0.7 });
    const line1 = new T.Line(geo1, mat), line2 = new T.Line(geo2, mat);
    scene.add(line1); scene.add(line2);
    return { N, positions, geo1, geo2, attr1, attr2, line1, line2, idx:0, count:0 };
  }

  function kepler(a,e,period,days){ const M=(2*Math.PI/period)*days; let E=M; for(let i=0;i<8;i++){ const f=E-e*Math.sin(E)-M, fp=1-e*Math.cos(E); E-=f/fp; } const cosE=Math.cos(E), sinE=Math.sin(E); const r=a*(1-e*cosE); const nu=Math.atan2(Math.sqrt(1-e*e)*sinE, cosE-e); return { r, nu }; }

  const bodies = planets.map(p=>{
    const mesh=new T.Mesh(new T.SphereGeometry(p.size,28,18), new T.MeshStandardMaterial({color:p.color,roughness:0.55,metalness:0.15}));
    const label=makeLabelSprite(p.name); label.scale.set(16,8,1); label.position.set(0,p.size*2.2,0); mesh.add(label);
    scene.add(mesh);
    const r=p.a*unitsPerAU; const ring=new T.Mesh(new T.RingGeometry(r-0.5,r+0.5,256), new T.MeshBasicMaterial({color:0x3a5c9e,side:T.DoubleSide,transparent:true,opacity:0.18})); ring.rotation.x=Math.PI/2; sun.add(ring);
    const trail = createTrail(p.color);
    const axis = new T.Object3D(); axis.rotation.z = T.MathUtils.degToRad(p.tilt||0); mesh.add(axis);
    return {...p, mesh, label, ring, trail, axis, moons:[], rings:null};
  });

  function setOrbitVisibility(){ bodies.forEach(b=> b.ring.visible = orbitsChk.checked); }
  function setNameVisibility(){ bodies.forEach(b=> b.label.visible = namesChk.checked); }
  setOrbitVisibility(); setNameVisibility();
  orbitsChk.addEventListener('change', setOrbitVisibility);
  namesChk.addEventListener('change', setNameVisibility);

  // Saturn rings
  function addSaturnRings(){
    const saturn = bodies.find(b=> b.name==='Saturn'); if (!saturn) return;
    if (saturn.rings){ saturn.mesh.remove(saturn.rings); }
    const inner = saturn.size * 1.3, outer = saturn.size * 2.6;
    const group = new T.Group();
    const makeBand=(r0,r1,alpha)=>{ const g=new T.RingGeometry(r0,r1,256); const m=new T.MeshBasicMaterial({ color:0xf6ecd1, side:T.DoubleSide, transparent:true, opacity:alpha }); const mesh=new T.Mesh(g,m); mesh.rotation.x=Math.PI/2; return mesh; };
    group.add(makeBand(inner, inner*1.25, 0.22));
    group.add(makeBand(inner*1.28, inner*1.7, 0.18));
    group.add(makeBand(inner*1.72, outer, 0.14));
    group.rotation.z = T.MathUtils.degToRad(26.73);
    saturn.mesh.add(group); saturn.rings = group;
  }
  addSaturnRings();

  // Moons
  function buildMoons(){
    bodies.forEach(b=>{ b.moons.forEach(m=>{ scene.remove(m.mesh); scene.remove(m.trail.line1); scene.remove(m.trail.line2); }); b.moons=[]; });
    if (!moonsChk.checked) return;
    const AU_KM=149597870.7, mkAU=km=> km/AU_KM;
    const add=(hostName,m)=>{ const host=bodies.find(b=>b.name===hostName); if(!host) return; const mesh=new T.Mesh(new T.SphereGeometry(m.size,20,14), new T.MeshStandardMaterial({color:m.color||0xffffff,roughness:0.6,metalness:0.05})); scene.add(mesh); const trail=createTrail(m.color||0xffffff); host.moons.push({...m,mesh,trail,host}); };
    add('Earth',   { name:'Moon',     a:mkAU(384400),  e:0.0549, period:27.3217, size:0.27, color:0xd9d9d9 });
    add('Jupiter', { name:'Io',       a:mkAU(421700),  e:0.0041, period:1.769,   size:0.36, color:0xffe4a3 });
    add('Jupiter', { name:'Europa',   a:mkAU(671100),  e:0.009,  period:3.551,   size:0.31, color:0xcfe8ff });
    add('Jupiter', { name:'Ganymede', a:mkAU(1070400), e:0.0013, period:7.155,   size:0.52, color:0xd7d1bf });
    add('Jupiter', { name:'Callisto', a:mkAU(1882700), e:0.007,  period:16.689,  size:0.48, color:0xb7aa98 });
  }
  buildMoons(); moonsChk.addEventListener('change', buildMoons);

  // Focus dropdown
  function teleportAndFollow(obj){
    const targetPos = obj.position.clone();
    const toCam = camera.position.clone().sub(controls.target);
    const dist = Math.max(80, toCam.length());
    const viewDir = camera.getWorldDirection(new T.Vector3()).normalize().multiplyScalar(-1);
    camera.position.copy(targetPos).add(viewDir.multiplyScalar(dist));
    controls.target.copy(targetPos);
    followTarget = obj; followSun = true; followSunBtn.textContent = `Following ${focusSel.value} ✓`;
  }
  document.getElementById('focusGo').addEventListener('click', ()=>{
    const name = focusSel.value;
    if (name==='Sun') teleportAndFollow(sun); else { const b=bodies.find(x=>x.name===name); if (b) teleportAndFollow(b.mesh); }
  });

  // Buttons & sliders
  playBtn.addEventListener('click', ()=>{ running=!running; playBtn.textContent = running ? '⏸︎ Pause' : '▶︎ Play'; });
  speedInput.addEventListener('input', ()=>{ daysPerSecond=Number(speedInput.value); speedVal.textContent=daysPerSecond.toFixed(daysPerSecond<10?2:0); });
  scaleInput.addEventListener('input', ()=>{ unitsPerAU=Number(scaleInput.value); scaleVal.textContent=unitsPerAU; bodies.forEach(b=>{ const r=b.a*unitsPerAU; b.ring.geometry.dispose(); b.ring.geometry=new T.RingGeometry(r-0.5,r+0.5,256); }); });
  sunVInput.addEventListener('input', ()=>{ sunAUPerYear=Number(sunVInput.value); sunVVal.textContent=sunAUPerYear.toFixed(3); });
  resetCamBtn.addEventListener('click', ()=>{ camera.position.set(140,100,260); controls.target.set(0,0,0); controls.update(); });
  followSunBtn.addEventListener('click', ()=>{ followSun=!followSun; followSunBtn.textContent = followSun ? `Following ${focusSel.value} ✓` : 'Follow Target'; });
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

  function updateTrail(trail,x,y,z,enabled){ const {N,positions,geo1,geo2,attr1,attr2}=trail; if(!enabled){ trail.idx=0; trail.count=0; geo1.setDrawRange(0,0); geo2.setDrawRange(0,0); return; } if(trail.count===0){ positions[0]=x;positions[1]=y;positions[2]=z; positions[3]=x;positions[4]=y;positions[5]=z; trail.idx=2; trail.count=2; geo1.setDrawRange(0,2); geo2.setDrawRange(0,0); attr1.needsUpdate=true; attr2.needsUpdate=true; return; } const i=trail.idx%N; positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z; trail.idx++; trail.count=Math.min(trail.count+1,N); if(trail.count<N){ geo1.setDrawRange(0,trail.count); geo2.setDrawRange(0,0);} else { const head=trail.idx%N; geo1.setDrawRange(0,head); geo2.setDrawRange(head,N-head);} attr1.needsUpdate=true; attr2.needsUpdate=true; }

  // Animate
  let last=performance.now();
  function animate(ts){
    const dt=(ts-last)/1000; last=ts; if (running) t+=dt*daysPerSecond;
    const years=t/365.25; const sunForward=sunAUPerYear*years*unitsPerAU; sun.position.set(0,0,sunForward); sunlight.position.copy(sun.position);
    applyWASD(dt);
    bodies.forEach(b=>{
      let x,y,rAU; if (ellipticalChk.checked){ const sol=kepler(b.a,b.e,b.period,t); rAU=sol.r; const nu=sol.nu; x=rAU*Math.cos(nu); y=rAU*Math.sin(nu);} else { const ang=(Math.PI*2/b.period)*t; rAU=b.a; x=rAU*Math.cos(ang); y=rAU*Math.sin(ang);} const px=x*unitsPerAU, py=y*unitsPerAU; b.mesh.position.set(sun.position.x+px, sun.position.y+py, sun.position.z);
      if (axialChk.checked && b.spin){ const rotPerDay = 24/Math.abs(b.spin); const dir=b.spin>=0?1:-1; b.mesh.rotation.y += dir * rotPerDay * dt * Math.PI*2 / b.period; }
      updateTrail(b.trail, b.mesh.position.x, b.mesh.position.y, b.mesh.position.z, trailsChk.checked);
    });
    bodies.forEach(host=>{
      const hostRadiusUnits = host.mesh.geometry.parameters.radius || 1; const minAU=(hostRadiusUnits*2.2)/unitsPerAU;
      host.moons.forEach(m=>{ const base=ellipticalChk.checked?kepler(m.a,m.e||0,m.period,t):{r:m.a,nu:(2*Math.PI/m.period)*t}; const rAU=Math.max(base.r,minAU); const mx=rAU*Math.cos(base.nu)*unitsPerAU, my=rAU*Math.sin(base.nu)*unitsPerAU; const hx=host.mesh.position.x, hy=host.mesh.position.y, hz=host.mesh.position.z; m.mesh.position.set(hx+mx, hy+my, hz); updateTrail(m.trail, m.mesh.position.x, m.mesh.position.y, m.mesh.position.z, trailsChk.checked); });
    });
    if (!followTarget) followTarget = sun;
    if (followSun){ const tp = (followTarget===sun) ? sun.position : followTarget.position; controls.target.lerp(tp, 0.12); camera.position.sub(controls.target).add(tp); }
    controls.update(); renderer.render(scene,camera); requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}
</script>
</body>
</html>
